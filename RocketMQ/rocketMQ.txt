1.消息队列的作用
异步处理：
过去，客户端向服务端发送请求，需要等待服务端处理完成才能进行下一步，
有了异步处理，客户端可以直接发送任务消息到消息队列，然后就可以直接
进行下一步，当消息处理完成以后，通过回调函数来确认处理结果。

系统解耦：
过去，客户端需要显式指定调用哪个服务器，有了消息队列，我们可以将需要
处理的消息发送到消息队列，由消息队列分派给指定的服务器。

流量削峰：
一般，不会让服务器的性能配置到可能应付最大流量的阈值，通过消息队列，
我们可以让峰值的流量通过一段时间慢慢消化，避免服务器压力承载多大。

提高性能：
通过系统解耦，我们可以对一些需要消耗性能的任务分派多个服务器来处理消息，
从而提高系统性能。

2.消息队列基本结构
生产者：发送消息到指定topic
生产者组：发送一类指定消息的生产者构成的集合
topic：逻辑消息地址
消费者：通过push或者pull的方式消费topic中的信息
消费者组：接收一类指定消息的消费者构成的集合

消息类型：
同步处理 
异步处理 提供一个回调函数，处理完成由消费者调用这个回调函数
单向消息 将消息发送到消息队列就不管了，无论它处理成功还是失败

3.常见消费模式
集群模式：
一条消息只会被同一个消费者组的一个消费者消费
广播模式
一条消息会同时被同一个消费者组的所有消费者消费
3.rocketMQ架构
producer 生产消息
nameserver 担任注册中心，生产者和消费者通过nameserver获取broker信息，
每个生产者和消费者只会与一台nameserver建立长连接，但是会和nameserver
的所有broker建立连接，可以同事配置多个nameserver，不同的nameserver互不
通信，无法知道其他nameserver的存在
topic 逻辑消费地址，topic可以分布在不同的broke，r中，称为分片，默认一个topic
会对应四个消息队列，消息队列是消息的物理地址实际消息是发送在队列中，消费组
的每个消费者分别对应topic不同的消息队列，同一个消费组的消费者数量不应该大于
topic对应的消息队列数量，否则其中的一些消费者没法消费
broker 对应服务器，每个broker可以包含不同topic的不同消息队列
consumer 通过nameserver获取broker信息，与所有的broker建立连接，通过指定的topic
从broker中获取信息

	
	

